Binary Trees

Welcome to the "binary_trees" repository! This repository explores the concept of binary trees, a fundamental data structure used for organizing and storing data in a hierarchical manner. It covers various operations and algorithms related to binary trees, including traversaltechniques, insertion, deletion, and balancing.

Table of Contents

Introduction

Installation

Usage

Contributing

License

Introduction

A binary tree is a hierarchical data structure consisting of nodes, where each node has at most two children, referred to as the left child and the right child. Binary trees are commonly used in computer science for representing hierarchical relationships, such as the structure of a file system, the organization of data in a database, or the hierarchical structure of a webpage.

This repository provides examples and exercises to help developers understand the principles of binary trees, common operations performed on binary trees, and algorithms for traversing, inserting, deleting, and balancing binary trees.

Installation

To use the code and examples in this repository, follow these steps:

1. Clone the repository to your local machine:

```
git clone https://github.com/Bruka25/binary_trees
```

2. Navigate to the repository directory:
```
cd binary_trees
```

3. You're ready to explore the code related to binary trees!

Usage

This repository contains implementations of binary trees and various algorithms related to binary trees. To make use of the repository:

1. Navigate to the directory containing the binary tree implementations:

```
cd binary_trees
```

2. Explore the source code files available in the repository. Each file contains an implementation of a binary tree or an algorithm related to binary trees.

3. Open the source code files to view the implementation details and comments explaining how binary trees are implemented and how algorithms are applied to binary trees.

4. Study the provided code and accompanying explanations to understand the principles of binary trees, common operations performed on binary trees, and algorithms for traversing, inserting, deleting, and balancing binary trees.

5. Experiment with the code, modify it as needed, and test different scenarios to deepen your understanding of binary trees and their capabilities.

6. Feel free to use the provided code snippets and examples as references for implementing binary trees in your own projects or for learning purposes.

Contributing

Contributions to this repository are welcome! If you have ideas for improving existing code, adding new implementations or algorithms related to binary trees, or fixing issues, please feel free to submit a pull request. Before contributing, please review the contribution guidelines.

License

This repository is licensed under the MIT License. See the LICENSE file for details.


The following C functions are for the poject binary_trees for the lower level programming curriculum of ALX, inside it contains the following C functions:


* A function that creates a binary tree node
* A function that inserts a node as the left-child of another node
* A function that inserts a node as the right-child of another node
* A function that deletes an entire binary tree
* A function that checks if a node is a leaf
* A function that checks if a given node is a root
* A function that goes through a binary tree using pre-order traversal
* A function that goes through a binary tree using in-order traversal
* A function that goes through a binary tree using post-order traversal
* A function that measures the height of a binary tree
* A function that measures the depth of a node in a binary tree
* A function that measures the size of a binary tree
* A function that counts the leaves in a binary tree
* A function that counts the nodes with at least 1 child in a binary tree
* A function that measures the balance factor of a binary tree
* A function that checks if a binary tree is full
* A function that checks if a binary tree is perfect
* A function that finds the sibling of a node
* A function that finds the uncle of a node
* A function that finds the lowest common ancestor of two nodes
* A function that goes through a binary tree using level-order traversal
* A function that checks if a binary tree is complete
* A function that performs a left-rotation on a binary tree
* A function that performs a right-rotation on a binary tree
* A function that checks if a binary tree is a valid Binary Search Tree
* A function that inserts a value in a Binary Search Tree
* A function that builds a Binary Search Tree from an array
* A function that searches for a value in a Binary Search Tree
* A function that removes a node from a Binary Search Tree
* The average time complexities of those operations on a Binary Search Tree (one answer per line):
                  -> Inserting the value n
                  -> Removing the node with the value n
                  -> Searching for a node in a BST of size n
* A function that checks if a binary tree is a valid AVL Tree
* A function that inserts a value in an AVL Tree
* A function that builds an AVL tree from an array
* A function that removes a node from an AVL tree
* A function that builds an AVL tree from an array
* The average time complexities of those operations on an AVL Tree (one answer per line):
                   -> Inserting the value n
                   -> Removing the node with the value n
                   -> Searching for a node in an AVL tree of size n
* A function that checks if a binary tree is a valid Max Binary Heap
* A function that inserts a value in Max Binary Heap
* A function that builds a Max Binary Heap tree from an array
* A function that extracts the root node of a Max Binary Heap
* A function that converts a Binary Max Heap to a sorted array of integers
* The average time complexities of those operations on a Binary Heap (one answer per line):
                    -> Inserting the value n
                    -> Extracting the root node
                    -> Searching for a node in a binary heap of size n
